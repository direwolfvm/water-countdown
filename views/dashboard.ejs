<section class="card">
  <% const targetLabel = selectedFountain ? selectedFountain.target : 30000; %>
  <div class="card-header">
    <div>
      <h2><%= selectedFountain ? selectedFountain.name : "No fountain selected" %></h2>
      <p class="muted">Target: <%= targetLabel %></p>
    </div>
    <% if (fountains.length > 0) { %>
      <form method="GET" action="/" class="inline-form">
        <label for="fountain_id" class="sr-only">Select fountain</label>
        <select id="fountain_id" name="fountain_id">
          <% fountains.forEach((fountain) => { %>
            <option value="<%= fountain.id %>" <%= selectedFountain && fountain.id === selectedFountain.id ? "selected" : "" %>>
              <%= fountain.name %>
            </option>
          <% }); %>
        </select>
        <button type="submit" class="button">Switch</button>
      </form>
    <% } %>
  </div>
</section>

<section class="card">
  <h2>Projection</h2>
  <% if (projection.hasProjection) { %>
    <div class="projection-grid">
      <div>
        <p class="label">Projected date to reach <%= targetLabel %></p>
        <p class="value"><%= projection.projectedDate %></p>
      </div>
      <div>
        <p class="label">Days remaining</p>
        <p class="value"><%= projection.daysRemaining %></p>
      </div>
    </div>
  <% } else { %>
    <p class="muted"><%= projection.errorMessage %></p>
  <% } %>
</section>

<section class="card">
  <div class="card-header">
    <h2>Observation Trend</h2>
    <a class="button" href="/observations">View and add observations</a>
  </div>
  <div class="chart-wrap">
    <% if (chartPoints.length === 0) { %>
      <p class="muted">No observations yet. Add some on the management page.</p>
    <% } else { %>
      <canvas id="observationsChart" width="400" height="200"></canvas>
    <% } %>
  </div>
  <div class="regression-panel">
    <h3>Regression equation</h3>
    <% if (projection.hasRegression) { %>
      <p><strong>y = m * t + b</strong></p>
      <p>m (slope): <%= (projection.regression.slope * 86400).toFixed(4) %> per day</p>
      <p>b (intercept): <%= projection.regression.intercept.toFixed(2) %></p>
      <p>t = days since <%= new Date(projection.regression.t0).toISOString().slice(0, 10) %></p>
    <% } else { %>
      <p class="muted">Regression not available yet.</p>
    <% } %>
  </div>
</section>

<% if (chartPoints.length > 0) { %>
<script>
  const chartPoints = <%- JSON.stringify(chartPoints) %>;
  const regressionLine = <%- JSON.stringify(regressionLine) %>;
  const chartStartMs = <%- JSON.stringify(chartStartMs) %>;
  const ctx = document.getElementById("observationsChart").getContext("2d");

  // Calculate weekend annotations
  function getWeekendAnnotations(startMs, points) {
    if (points.length === 0) return {};

    const annotations = {};
    const minX = 0;
    const maxX = Math.max(...points.map(p => p.x));

    // Start from the chart start date
    const startDate = new Date(startMs);
    const endDate = new Date(startMs + maxX * 1000);

    // Find first Saturday at or before start
    const current = new Date(startDate);
    current.setHours(0, 0, 0, 0);
    while (current.getDay() !== 6) {
      current.setDate(current.getDate() - 1);
    }

    let weekendIndex = 0;
    while (current <= endDate) {
      // Saturday start
      const satStart = new Date(current);
      // Monday start (end of weekend)
      const monStart = new Date(current);
      monStart.setDate(monStart.getDate() + 2);

      // Convert to x-axis values (seconds from chartStartMs)
      const xMin = (satStart.getTime() - startMs) / 1000;
      const xMax = (monStart.getTime() - startMs) / 1000;

      // Only add if weekend overlaps with chart range
      if (xMax > minX && xMin < maxX) {
        annotations[`weekend${weekendIndex}`] = {
          type: 'box',
          xMin: Math.max(xMin, minX),
          xMax: Math.min(xMax, maxX),
          backgroundColor: 'rgba(0, 0, 0, 0.05)',
          borderWidth: 0,
        };
        weekendIndex++;
      }

      // Move to next Saturday
      current.setDate(current.getDate() + 7);
    }

    return annotations;
  }

  const weekendAnnotations = getWeekendAnnotations(chartStartMs, chartPoints);

  const datasets = [
    {
      label: "Observations",
      data: chartPoints,
      borderColor: "#1b4965",
      backgroundColor: "rgba(27, 73, 101, 0.15)",
      tension: 0.2,
      showLine: true,
      pointRadius: 4,
    },
  ];

  if (regressionLine.length > 0) {
    datasets.push({
      label: "Regression",
      data: regressionLine,
      borderColor: "#5fa8d3",
      backgroundColor: "rgba(95, 168, 211, 0.15)",
      borderDash: [6, 6],
      showLine: true,
      pointRadius: 0,
      tension: 0,
    });
  }

  new Chart(ctx, {
    type: "scatter",
    data: {
      datasets,
    },
    options: {
      responsive: true,
      parsing: false,
      plugins: {
        legend: {
          display: true,
        },
        tooltip: {
          callbacks: {
            label: (context) => {
              const seconds = context.parsed.x || 0;
              const date = new Date(chartStartMs + seconds * 1000);
              return `${context.dataset.label}: ${context.parsed.y} (${date.toLocaleDateString("en-US")})`;
            },
          },
        },
        annotation: {
          annotations: weekendAnnotations,
        },
      },
      scales: {
        x: {
          type: "linear",
          title: {
            display: true,
            text: "Date",
          },
          ticks: {
            callback: (value) => {
              const date = new Date(chartStartMs + value * 1000);
              return date.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
              });
            },
            maxTicksLimit: 6,
          },
        },
        y: {
          title: {
            display: true,
            text: "Counter value",
          },
          beginAtZero: false,
        },
      },
    },
  });
</script>
<% } %>
